// Build script for this project. May used in IDE or CI environment

// Copyright 2021 by tobi@backfrak.de. All
// rights reserved. Use of this source code is governed
// by a BSD-style license that can be found in the
// LICENSE file.

defaultTasks 'build'
ext.goExe = project.hasProperty('goExe') ? project.getProperty('goExe') : 'go'
def programVersion=''
def programVersionShort=''
def programVersionNumber=''
def debPackageName=''
def debPackageVersion=''
def debPackageTmpDir=''
def scriptDirectory
def scriptFile
def osName
def osVersion
String srcDir
String binDir
String pkgDir
String logDir
String tmpDir
ext.packageRoot = project.hasProperty('packageRoot') ? project.getProperty('packageRoot') : 'tmp'
String versionFile
String packagesToBuild = ''
String packagesToTest = ''
def raceParameter

def getGitHash = { ->
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'describe', '--always', '--long', '--dirty'
        standardOutput = stdout
    }
    return stdout.toString().trim()
}

def getGitHight = { ->

    // Get the last commit in Version.txt
    def stdout = new ByteArrayOutputStream()
    def lastVersionChange 
    exec {
        commandLine 'git', 'log', '--pretty=format:"%H"', '-n 1', '--follow', versionFile
        standardOutput = stdout
    }
    lastVersionChange = stdout.toString().trim()
    lastVersionChange = lastVersionChange.replaceAll (/"/, '') 

    // Get the last commit in the repo
    stdout = new ByteArrayOutputStream()
    def head 
    exec {
        commandLine 'git', 'log', '--pretty=format:"%H"', '-n 1'
        standardOutput = stdout
    }
    head = stdout.toString().trim()
    head = head.replaceAll (/"/, '') 

    // Count commits between lastVersionChange and head (this is the hight)
    stdout = new ByteArrayOutputStream()
    def hight 
    exec {
        commandLine 'git', 'rev-list', '--count', lastVersionChange + '..' + head
        standardOutput = stdout
    }
    hight = stdout.toString().trim() 
    println "Git hight: ${hight}"

    return hight
}

task getEnvironment {
    description 'Setup the environment for the build'
    doFirst{
        println '##################################################################################'
        println 'Setup the environment'
        println '##################################################################################'
        osName = org.gradle.internal.os.OperatingSystem.current().getName()
        osVersion = org.gradle.internal.os.OperatingSystem.current().getVersion()
        println "$osName $osVersion was detected."
        println "Github Runner OS: ${System.env.GITHUB_RUNNER_OS}"

        // Find the location in the file system
        scriptFile = buildscript.sourceFile
        scriptDirectory = scriptFile.getParent()
        println 'Script directory is: ' + scriptDirectory

        srcDir = "$scriptDirectory" + File.separator + "src" + File.separator
        binDir = "$scriptDirectory" + File.separator + "bin" + File.separator
        pkgDir = "$scriptDirectory" + File.separator + "pkg" + File.separator
        logDir = "$scriptDirectory" + File.separator + "logs" + File.separator
        tmpDir = "$scriptDirectory" + File.separator + "tmp" + File.separator
        versionFile = "$scriptDirectory" + File.separator + "VersionMaster.txt"

        def logDirBase = new File(logDir)
        logDirBase.mkdirs()

        if ( osName.contains('Windows') == true) {
            raceParameter = ''
        } else {
            raceParameter = '-race'
        }
        

        programVersionShort=new File(versionFile).text
        programVersionNumber = programVersionShort + "." + getGitHight()
        programVersion= programVersionNumber + "-" + getGitHash()
        

        if (("${System.env.GITHUB_RUNNER_OS}" != "null") && ("${System.env.GITHUB_RUNNER_OS}" != "")) {
            debPackageVersion= "${programVersion}+${System.env.GITHUB_RUNNER_OS}"
            

        } else {
            debPackageVersion= "${programVersion}"
        }
        debPackageName = "samba-exporter_${debPackageVersion}"

        debPackageTmpDir = "$scriptDirectory" + File.separator + "${packageRoot}" + File.separator + "${debPackageName}" + File.separator
        println "Program version: ${programVersion}"
        println "Package Name: ${debPackageName}"
       

        // Find all directories within src/ that contains *.go files
        new File(srcDir).traverse( [maxDepth: 100, filter: ~/.*.go/ , type: groovy.io.FileType.FILES]){
                String packageDir = it.getParent()
                String packageName = packageDir.replaceAll(java.util.regex.Matcher.quoteReplacement(srcDir), '')
                if ((packagesToBuild.contains(packageName + ' ') == false) 
                    && (packageName.contains("tobi.backfrak.de${File.separator}cmd") == true) 
                    && file("${packageDir}${File.separator}main.go").exists()) {
                    packagesToBuild = "src${File.separator}${packageName}" + ' ' + packagesToBuild
                }
        }

        // Find all directories within src/ that contains *_test.go files
        new File(srcDir).traverse( [maxDepth: 100, filter: ~/.*_test.go/, type: groovy.io.FileType.FILES]){
                String packageDir = it.getParent()
                String packageName = packageDir.replaceAll(java.util.regex.Matcher.quoteReplacement(srcDir), '')
                if ((packagesToTest.contains(packageName + ' ') == false) 
                    && (packageName.contains('tobi.backfrak.de') == true) 
                    && file("${packageDir}${File.separator}go.mod").exists()) {
                    packagesToTest = "src${File.separator}${packageName}" + ' ' + packagesToTest
                }
        }
        if (File.separator == '\\') {
            packagesToBuild = packagesToBuild.replaceAll(java.util.regex.Matcher.quoteReplacement(File.separator), '/')
            packagesToTest = packagesToTest.replaceAll(java.util.regex.Matcher.quoteReplacement(File.separator), '/')
        }

        println "Go Packages to build: $packagesToBuild"
        println "Go Packages to test: $packagesToTest"

    }
}

task getBuildName(dependsOn: 'clean') {
    description 'Just print out the version and number of the build'
    doFirst {

    }
    doLast {
        println "Package Version: ${debPackageVersion}"
        println "Package Name: ${debPackageName}"
        file("${logDir}${File.separator}Version.txt").text = "${debPackageVersion}"
        file("${logDir}${File.separator}PackageName.txt").text = "${debPackageName}"
        file("${logDir}${File.separator}ShortVersion.txt").text = "${programVersionNumber}"

    }
}

task installTestConvert(dependsOn: 'getEnvironment') {
    description 'Install all dependecies needed for test result conversion'
    doFirst {
        println '##################################################################################'
        println 'Install Test Result conversion tools '
        println '##################################################################################'
    }
    doLast {
        // Install go get github.com/tebeka/go2xunit so it can be used after test execution
        println "${goExe} install -v github.com/tebeka/go2xunit@v1.4.10"
        exec {
            workingDir "${scriptDirectory}${File.separator}build"
            commandLine "${goExe}", 'install', '-v' ,'github.com/tebeka/go2xunit@v1.4.10'
        }
    }
}

task clean(dependsOn: 'getEnvironment') {
    description 'Delete all output from older builds'
    doFirst {
        println '##################################################################################'
        println 'Clean up'
        println '##################################################################################'
    }
    doLast {
        println "Delete binaries in $binDir"
        delete fileTree(binDir) {

        }
        println "Delete packages in $pkgDir"
        delete fileTree(pkgDir) {

        }
        println "Delete logs in $logDir"
        delete fileTree(logDir) {

        }
        
        println "Delete tmp files in $tmpDir"
        delete fileTree(tmpDir) {

        }

        println "Delete zips in $scriptDirectory"
        delete fileTree(scriptDirectory) {
            include "*.zip"
        }
    }
}

task test(dependsOn: 'getEnvironment') {
    description 'Run all go tests'
    doFirst {
        println '##################################################################################'
        println 'Run tests'
        println '##################################################################################'
    }
    doLast {
        def packageArray = packagesToTest.split(' ');
        def callArgsTestRun = new String[3]
        callArgsTestRun[0] = 'test'
        callArgsTestRun[1] = '-v'
        callArgsTestRun[2] = raceParameter
        def outtext = ""
        packageArray.each { packageDir ->
            def outputStream = new ByteArrayOutputStream()
            println "cd $packageDir && ${goExe} test -v $raceParameter  >> ${logDir}TestsRun.log "
            exec {
                workingDir "${scriptDirectory}${File.separator}${packageDir}"
                executable "${goExe}"
                args callArgsTestRun

                standardOutput outputStream
                errorOutput outputStream
            } 
            outtext = outtext + outputStream.toString()
            file("${logDir}TestsRun.log").text = outtext 
        }
    }
}

task cover(dependsOn: 'getEnvironment') {
    description 'Run all go tests with coverage'
    doFirst {
        println '##################################################################################'
        println 'Run tests -cover'
        println '##################################################################################'
    }
    doLast {
        def packageArray = packagesToTest.split(' ');
        def callArgsTestRun = new String[3]
        callArgsTestRun[0] = 'test'
        callArgsTestRun[1] = '-v'
        callArgsTestRun[2] = '-cover'
        def outtext = ""
        packageArray.each { packageDir ->
            def outputStream = new ByteArrayOutputStream()
            println "cd $packageDir && ${goExe} test -v -cover  >> ${logDir}TestsCoverRun.log "
            exec {
                workingDir "${scriptDirectory}${File.separator}${packageDir}"
                executable "${goExe}"
                args callArgsTestRun

                standardOutput outputStream
                errorOutput outputStream
            } 
            outtext = outtext + outputStream.toString()
            file("${logDir}TestsCoverRun.log").text = outtext 
        }
    }
}

task convertTestResults(dependsOn: 'installTestConvert') {
     description 'Convert the test results'
    doFirst {
        println '##################################################################################'
        println 'Convert the test results'
        println '##################################################################################'
    }
    doLast {
        def logTextFile = logDir + 'TestsRun.log'
        def logXMLFile = logDir + 'TestsResult.xml'
        def convertExe = binDir + 'go2xunit'
        println "${goExe} run github.com/tebeka/go2xunit -input ${logTextFile} -output ${logXMLFile}"
        exec {
            workingDir "${scriptDirectory}${File.separator}build"
            commandLine "${goExe}", 'run', 'github.com/tebeka/go2xunit', '-input', logTextFile, '-output', logXMLFile
        }
    }
}

task build(dependsOn: 'clean') {
    description 'Compile all go packages'
    doFirst {
        println '##################################################################################'
        println 'Build'
        println '##################################################################################'

    }
    doLast {
        def versionArg ='-X main.version=' + "${programVersion}" +''
        def packageArray = packagesToBuild.split(' ');
        def callArgs = new String[6]
        callArgs[0] = 'build'
        callArgs[1] = '-v'
        callArgs[2] = "-ldflags"
        callArgs[3] = versionArg
        callArgs[4] = '-o'
        callArgs[5] = "$binDir"
        packageArray.each { packageDir ->
            println "cd $packageDir && ${goExe} build -o $binDir -v -ldflags=\"-X main.version=${programVersion}\""
            exec {
                workingDir "${scriptDirectory}${File.separator}${packageDir}"
                executable "${goExe}"
                args callArgs
            }

        }
    }
}

task preparePack(dependsOn: 'build') {
    description 'Prepare a folder for packageing'
    doFirst {
        println '##################################################################################'
        println 'Prepare a folder for packageing'
        println '##################################################################################'
        println "Copy files for packaging to ${debPackageTmpDir}"
    }
    
    doLast {
        copy {
            // Copy all data from the install directory to the package tmp dir
            from ('install/debian'){
                include '**/**'
            }
            into "${debPackageTmpDir}/debian"
        }

        copy {
            // Copy docs to the package tmp dir
            from('.') {
                include 'changelog'
            }
            into "${debPackageTmpDir}/debian"
        }

        file("${debPackageTmpDir}/debian").renameTo(file("${debPackageTmpDir}/DEBIAN"))

        // Copy and strip bin files
        exec {
            commandLine "${scriptDirectory}/build/InstallProgram.sh", "${scriptDirectory}", "${scriptDirectory}/bin/", "${debPackageTmpDir}", "${programVersionShort}"
        }

        copy {
            // Copy docs to the package tmp dir
            from('.') {
                include 'LICENSE'
                include 'changelog'
            }
            into "${debPackageTmpDir}/usr/share/doc/samba_exporter/"
        }

        copy {
            // Copy docs to the package tmp dir
            from('install/debian') {
                include 'copyright'
            }
            into "${debPackageTmpDir}/usr/share/doc/samba_exporter/"
        }
    }
}

// Do something after each task, no taking care about the state
gradle.taskGraph.afterTask { taskWasRunning, TaskState state ->

    // Find out what task was running before
   if ((taskWasRunning == build) || (taskWasRunning == test))  {
        println "$taskWasRunning exit"

   }
}
